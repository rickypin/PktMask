# PktMask - IP 地址替换说明文档

PktMask 是一个专门用于处理网络数据包文件中 IP 地址替换的工具。本文档详细说明了 PktMask 的 IP 地址替换逻辑和实现方法。

---

### 一、基本原则

无论是 IPv4 还是 IPv6，整个替换过程遵循两个基本原则：

1. **局部随机替换：**  
   每个地址的某一段（数字块）都会在原值附近随机生成一个新值，这样既防止了直接暴露真实数据，又保证替换后的数字与原数值在范围上"相似"，避免数据结构完全失去参照意义。

2. **分层一致性替换：**  
   在预扫描过程中统计了所有地址的各层前缀出现频率。如果某一前缀（例如 IPv4 的前两块或 IPv6 的前四组）在多个地址中出现，则程序保证这些地址在替换后共享相同的新前缀。这使得例如同一子网中的 IP 地址，替换后仍能表现出"同属一组"的特性。

通过下面的具体示例可以看到：

- **共享前缀的地址**（如 192.168.1.10 与 192.168.1.20）在替换后保持了相同的新前缀（如 187.172.3.x）。
- **部分共享前缀的地址**（如 192.168.2.30 与 192.168.1.10）在相同部分上（第一、第二块）保持一致，而在不同的部分（第三块）则独立随机替换。
- **独立地址**（如 10.0.0.5）全部采用独立替换，不受其它地址的影响。

这样的设计既能有效隐藏真实 IP，又能在替换数据中保留一定的层次和结构信息，方便后续数据分析和调试，同时确保同一网络段内的地址替换结果保持一致，便于观察网络结构。

### 二、对于 IPv4 地址

IPv4 地址由四个数字块构成（例如：A.B.C.D）。程序对前三个数字块分别进行"局部随机替换"，而最后一块始终保持不变。更重要的是，在扫描所有文件后，程序会统计各层级（第一块、前两块、前三块）的出现次数。如果某一层级的数值在多个地址中出现，则用同一个新的数字替换所有地址中的该部分；如果某个段只在单个地址中出现，则单独随机生成新的数字。

**示例场景：**

假设有以下几个 IPv4 地址：

1. **地址组 1（共享相同前两块）：**  
   - 192.168.1.10  
   - 192.168.1.20  
   
   **处理逻辑：**  
   - **第一块（192）：** 所有地址中若"192"出现多次，则程序为它生成一个新的数字（例如 187），所有出现"192"的地址统一替换为 187。  
   - **第二块（168）：** 因为这两条地址均以"192.168"开头，所以第二块也会统一替换，比如将 168 替换为 172。  
   - **第三块（1）：** 这两条地址共享完整的前缀"192.168.1"，因此第三块也统一替换，如 1 替换为 3。  
   - **第四块：** 保持原样。  
   
   **替换后可能得到：**  
   - 192.168.1.10 → **187.172.3.10**  
   - 192.168.1.20 → **187.172.3.20**

2. **地址组 2（部分共享）：**  
   - 192.168.2.30  
   
   **处理逻辑：**  
   - 第一块"192"和第二块"168"与组1相同，因此替换结果与组1保持一致（分别变为 187 和 172）。  
   - 第三块不同（原值为 2，与组1的 1 不同），因此第三块将单独随机替换，比如 2 可能替换为 5。  
   - 第四块保持不变。  
   
   **替换后可能得到：**  
   - 192.168.2.30 → **187.172.5.30**

3. **地址组 3（独立地址）：**  
   - 10.0.0.5  
   
   **处理逻辑：**  
   - 该地址的第一块"10"没有与其他地址共享（或出现次数较少），因此它的替换完全独立，比如 10 可能替换为 12；第二块"0"和第三块"0"也是各自单独替换（例如分别替换为 5 和 2）；第四块依然不变。  
   
   **替换后可能得到：**  
   - 10.0.0.5 → **12.5.2.5**

**总结 IPv4 替换特点：**  
- **一致性：** 在同一层级（如第一块、前两块或前三块）中，如果相同的数字重复出现，所有地址共享这一部分时就会统一替换成同一个新数字。  
- **局部随机性：** 每个数字块的新值都在原值附近（比如原数字±20左右的范围内）随机生成，但不会与原值相同。  
- **保留末尾：** 最后一块数字始终不做修改，保留了原始的某些信息。

### 三、对于 IPv6 地址

IPv6 地址由八组十六进制数字构成（例如：A:B:C:D:E:F:G:H）。程序对前 7 组依次进行替换，遵循与 IPv4 类似的分层原则，而最后一组保持原样。

**示例场景：**

假设有以下几个 IPv6 地址：

1. **地址组 1（共享前两组和部分后续组）：**  
   - 2001:0db8:85a3:0000:0000:8a2e:0370:7334  
   - 2001:0db8:85a3:0000:0000:8a2e:1234:5678  
   
   **处理逻辑：**  
   - **第一组（2001）：** 两个地址均为 2001，故替换为同一新值（例如 2003）。  
   - **第二组（0db8）：** 同理统一替换，如替换为 0db3。  
   - **第三组（85a3）：** 两个地址共享此组，故统一替换，比如将 85a3 替换为 85a0。  
   - **第四到第七组：** 若各自前缀完全相同，则统一替换（例如第四组 0000 可能都替换为 0001，依此类推）。  
   - **第八组：** 保持原样。  
   
   **替换后可能得到：**  
   - 2001:0db8:85a3:0000:0000:8a2e:0370:7334 → **2003:0db3:85a0:0001:0002:8a2b:0371:7334**  
   - 2001:0db8:85a3:0000:0000:8a2e:1234:5678 → **2003:0db3:85a0:0001:0002:8a2b:1234:5678**

2. **地址组 2（部分共享）：**  
   - 2001:0db8:85a4:0000:0000:8a2e:0370:1234  
   
   **处理逻辑：**  
   - 第一组和第二组依然与组1相同，统一替换为 2003 和 0db3；  
   - **第三组（85a4）** 与组1的第三组不同，因此单独替换，如 85a4 可能替换为 85a5；  
   - 后续组级别的替换也按照是否共享前缀来决定，统一或单独生成新值；  
   - 最后一组保持不变。  
   
   **替换后可能得到：**  
   - 2001:0db8:85a4:0000:0000:8a2e:0370:1234 → **2003:0db3:85a5:0001:0002:8a2b:0370:1234**

3. **地址组 3（仅第一组共享）：**  
   - 2001:0db9:85a3:0000:0000:8a2e:0370:abcd  
   
   **处理逻辑：**  
   - 第一组"2001"依然与前面的地址相同，所以替换成 2003；  
   - **第二组**不同（0db9 与前面的 0db8），因此会单独替换，如可能替换为 0db7；  
   - 第三组"85a3"与组1中的第三组一致（尽管第二组不同），程序可能按层级独立判断，此层可能单独替换，也可能因其它因素而统一——总体原则是：如果该层前缀在多个地址中出现（统计次数达到一定值），则统一替换；否则随机替换。假设这里将"85a3"统一替换为 85a0；  
   - 第四到第七组同样依次判断替换；  
   - 第八组保持原样。  
   
   **替换后可能得到：**  
   - 2001:0db9:85a3:0000:0000:8a2e:0370:abcd → **2003:0db7:85a0:0001:0002:8a2b:0370:abcd**

**总结 IPv6 替换特点：**  
- **层级替换：** 地址的前 7 组按顺序分别替换，若某一组在多个地址中重复出现，则使用相同的新值；  
- **保持部分原貌：** 最后一组不变，便于后续比对或调试；  
- **随机但相近：** 每一组的新值在数字上与原值相近（在一定的随机范围内浮动），既隐藏了真实信息，又保留了大体结构。

